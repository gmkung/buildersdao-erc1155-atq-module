import fetch from "node-fetch";

// Updated NFT interface to match query result structure
interface NFT {
  id: string;
  symbol: string;
  asAccount: {
    id: string;
  };
  supportsMetadata: boolean;
  name: string;
}

interface Tag {
  "Contract Address": string;
  "Public Name Tag": string;
  "Project Name": string;
  "UI/Website Link": string;
  "Public Note": string;
}

interface GraphQLResponse {
  data: {
    erc721Contracts: NFT[];
  };
}

const GET_POOLS_QUERY = `
  query GetPools($last_id: String!) {
    erc721Contracts(
      first: 1000,
      orderBy: id,
      orderDirection: asc,
      where: { id_gt: $last_id }
    ) {
      id
      symbol
      asAccount {
        id
      }
      supportsMetadata
      name
    }
  }
`;

async function returnTags(
  chainId: string,
  apiKey: string
): Promise<Tag[] | Error> {
  let last_id: string = "0";
  let allTags: Tag[] = [];
  let isMore = true;

  if (chainId !== "1") {
    throw new Error(
      `Unsupported Chain ID: ${chainId}. This function only supports Ethereum Mainnet.`
    );
  }

  if (!apiKey || apiKey.length < 20) {
    throw new Error("Invalid API key format.");
  }

  while (isMore) {
    const response = await fetch(
      "https://api.thegraph.com/subgraphs/name/your-subgraph-name/your-subgraph", // Adjust this URL to match your actual subgraph endpoint
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          query: GET_POOLS_QUERY,
          variables: { last_id: last_id },
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Network response was not ok: ${response.statusText}`);
    }
    const result = (await response.json()) as GraphQLResponse;
    const nfts: NFT[] = result.data.erc721Contracts;

    allTags.push(...transformPoolsToTags(chainId, nfts));

    if (nfts.length < 1000) {
      isMore = false;
    } else {
      last_id = nfts[nfts.length - 1].id;
    }
  }

  return allTags;
}

function transformPoolsToTags(chainId: string, nfts: NFT[]): Tag[] {
  return nfts.map((nft) => ({
    "Contract Address": `eip155:${chainId}:${nft.id}`,
    "Public Name Tag": `${nft.symbol} token`,
    "Project Name": nft.name,
    "UI/Website Link": `https://etherscan.io/address/${nft.asAccount.id}`, // Assuming the asAccount.id is the contract address
    "Public Note": `The contract for the ${nft.symbol} token of nft.name. ${
      nft.supportsMetadata ? "Supports metadata" : "Does not support metadata"
    }.`,
  }));
}

export { returnTags };
